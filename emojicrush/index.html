<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emoji Crush</title>
  <meta name="theme-color" content="#0f172a" />
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <div class="wrap">
    <h1>Emoji Crush</h1>

    <!-- Navbar simples: volta ao Leitor -->
    <nav class="navbar">
      <button class="nav-item" onclick="location.href='/emojiread'">Leitor</button>
      <button class="nav-item active" onclick="location.href='/emojicrush'">Jogo</button>
      <button class="nav-item" onclick="location.href='/'">In√≠cio</button>
    </nav>

    <!-- HUD -->
    <div class="hud">
      <div class="pill">Pontos: <span id="score">0</span></div>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="Tabuleiro de emojis"></div>
    </div>

    <p class="hint">Troque dois vizinhos. A troca s√≥ vale se formar 3+. Cascatas d√£o b√¥nus de pontua√ß√£o.</p>
  </div>

  <footer>
      Feito com ‚ù§Ô∏è para o Luc. Suporta voz nativa do navegador (Chrome/Android, Safari/iOS e Edge).
  </footer>

  <!-- √Åudios locais -->
  <audio id="swap-sound"  src="./sounds/pop.mp3"   preload="auto"></audio>
  <audio id="match-sound" src="./sounds/match.mp3" preload="auto"></audio>

  <script>
    // === Config ===
    const EMOJIS = ["üçé","üçå","üçá","üçì","üçç","üçä","üçí"];
    const SIZE = 8;
    const BASE_POINTS_PER_TILE = 10;

    // === Estado ===
    let board = [];          // board[y][x] => emoji | null
    let cells = [];          // cells[y][x] => elemento DOM
    let selected = null;     // {x,y, el}
    let dragStart = null;    // {x,y, clientX, clientY}
    let busy = false;
    let score = 0;

    const scoreEl = () => document.getElementById('score');
    function addScore(points) {
      score += points;
      const el = scoreEl();
      el.textContent = score;
      el.classList.remove('score-bump'); void el.offsetWidth; el.classList.add('score-bump');
    }

    // === Som ===
    let swapSound, matchSound;
    function getSwapSound() {
      if (!swapSound) { swapSound = document.getElementById('swap-sound') || new Audio('./sounds/pop.mp3'); swapSound.volume = 0.6; }
      return swapSound;
    }
    function getMatchSound() {
      if (!matchSound) { matchSound = document.getElementById('match-sound') || new Audio('./sounds/match.mp3'); matchSound.volume = 0.7; }
      return matchSound;
    }
    function primeAudio() {
      const s1 = getSwapSound(), s2 = getMatchSound();
      try {
        s1.volume = 0; s1.play().then(()=>{ s1.pause(); s1.currentTime=0; s1.volume=0.6; }).catch(()=>{});
        s2.volume = 0; s2.play().then(()=>{ s2.pause(); s2.currentTime=0; s2.volume=0.7; }).catch(()=>{});
      } catch {}
      window.removeEventListener('pointerdown', primeAudio);
      window.removeEventListener('touchstart', primeAudio);
      window.removeEventListener('click', primeAudio);
    }
    window.addEventListener('pointerdown', primeAudio, { once: true });
    window.addEventListener('touchstart', primeAudio, { once: true });
    window.addEventListener('click', primeAudio, { once: true });
    function playSwapSound()  { const a=getSwapSound();  a.currentTime=0; a.play().catch(()=>{}); }
    function playMatchSound() { const a=getMatchSound(); a.currentTime=0; a.play().catch(()=>{}); }

    // === Util ===
    const inBounds = (x, y) => x >= 0 && x < SIZE && y >= 0 && y < SIZE;
    const randomEmoji = () => EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
    function isAdjacent(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1; }
    function setBusy(on) { busy = on; document.getElementById('board').classList.toggle('busy', on); }

    function swapModel(a, b) {
      const tmp = board[a.y][a.x];
      board[a.y][a.x] = board[b.y][b.x];
      board[b.y][b.x] = tmp;
    }
    function renderSwap(a, b) {
      const ea = cells[a.y][a.x], eb = cells[b.y][b.x];
      const tmpTxt = ea.textContent; ea.textContent = eb.textContent; eb.textContent = tmpTxt;
      ea.classList.add('flash'); eb.classList.add('flash'); playSwapSound();
      setTimeout(()=>{ ea.classList.remove('flash'); eb.classList.remove('flash'); }, 250);
    }
    function clearSelection() { if (selected?.el) selected.el.classList.remove('selected'); selected = null; }

    // === Match-3 ===
    function findMatches() {
      const toClear = new Set();
      // Linhas
      for (let y=0;y<SIZE;y++){
        let run=1;
        for (let x=1;x<=SIZE;x++){
          const cur = x<SIZE? board[y][x]: null;
          const prev = board[y][x-1];
          if (cur===prev && cur!==null) { run++; }
          else {
            if (prev!==null && run>=3) for (let k=x-run; k<x; k++) toClear.add(`${k},${y}`);
            run=1;
          }
        }
      }
      // Colunas
      for (let x=0;x<SIZE;x++){
        let run=1;
        for (let y=1;y<=SIZE;y++){
          const cur = y<SIZE? board[y][x]: null;
          const prev = board[y-1][x];
          if (cur===prev && cur!==null) { run++; }
          else {
            if (prev!==null && run>=3) for (let k=y-run; k<y; k++) toClear.add(`${x},${k}`);
            run=1;
          }
        }
      }
      return toClear;
    }
    function markMatches(toClear){ toClear.forEach(key=>{ const [x,y]=key.split(',').map(Number); cells[y][x].classList.add('match'); }); }
    function clearMatches(toClear){
      playMatchSound();
      return new Promise(resolve=>{
        toClear.forEach(key=>{ const [x,y]=key.split(',').map(Number); cells[y][x].classList.add('vanish'); });
        setTimeout(()=>{
          toClear.forEach(key=>{
            const [x,y]=key.split(',').map(Number);
            board[y][x] = null; const cell=cells[y][x];
            cell.textContent=''; cell.classList.remove('match','vanish');
          });
          resolve();
        },180);
      });
    }
    function applyGravity(){
      for (let x=0;x<SIZE;x++){
        let write = SIZE-1;
        for (let y=SIZE-1;y>=0;y--){
          if (board[y][x]!==null){
            const v=board[y][x];
            if (y!==write){ board[write][x]=v; board[y][x]=null; }
            write--;
          }
        }
      }
      for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) cells[y][x].textContent = board[y][x] || '';
    }
    function refill(){
      for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) if (board[y][x]===null){
        const e=randomEmoji(); board[y][x]=e; cells[y][x].textContent=e;
      }
    }
    async function resolveBoardCascade(){
      let chain=1;
      while(true){
        const matches = findMatches();
        const count = matches.size;
        if (count===0) break;
        addScore(count * BASE_POINTS_PER_TILE * chain);
        markMatches(matches);
        await clearMatches(matches);
        applyGravity();
        refill();
        chain++;
        await new Promise(r=>setTimeout(r,60));
      }
    }
    function swapAndResolve(a,b){
      setBusy(true);
      swapModel(a,b); renderSwap(a,b);
      const hasMatch = findMatches().size>0;
      if (!hasMatch){
        setTimeout(()=>{ swapModel(a,b); renderSwap(a,b); setBusy(false); },140);
        return;
      }
      (async()=>{ await resolveBoardCascade(); setBusy(false); })();
    }

    // === Intera√ß√£o ===
    function chooseCell(x,y){
      if (busy) return;
      const el=cells[y][x];
      if (!selected){ selected={x,y,el}; el.classList.add('selected'); return; }
      const other={x,y,el};
      if (selected.x===x && selected.y===y){ clearSelection(); return; }
      if (!isAdjacent(selected,other)){ selected.el.classList.remove('selected'); selected=other; el.classList.add('selected'); return; }
      selected.el.classList.remove('selected'); const a=selected; const b=other; selected=null; swapAndResolve(a,b);
    }
    function onPointerDown(e,x,y){
      if (busy) return;
      const touch=e.touches?.[0]||e; dragStart={x,y,clientX:touch.clientX,clientY:touch.clientY};
      if (!selected){ selected={x,y,el:cells[y][x]}; selected.el.classList.add('selected'); }
    }
    function onPointerUp(e){
      if (busy || !dragStart) return;
      const t=e.changedTouches?.[0]||e; const dx=t.clientX-dragStart.clientX; const dy=t.clientY-dragStart.clientY;
      const TH=12; let nx=dragStart.x, ny=dragStart.y;
      if (Math.abs(dx)>Math.abs(dy) && Math.abs(dx)>TH) nx=dragStart.x+(dx>0?1:-1);
      else if (Math.abs(dy)>TH) ny=dragStart.y+(dy>0?1:-1);
      else { chooseCell(dragStart.x,dragStart.y); dragStart=null; return; }
      if (inBounds(nx,ny)){
        const a={x:dragStart.x,y:dragStart.y,el:cells[dragStart.y][dragStart.x]};
        const b={x:nx,y:ny,el:cells[ny][nx]};
        if (selected?.el) selected.el.classList.remove('selected'); selected=null; swapAndResolve(a,b);
      } else { clearSelection(); }
      dragStart=null;
    }

    // === Board ===
    function createBoard(){
      board = Array.from({length:SIZE}, ()=> Array.from({length:SIZE}, ()=> randomEmoji()));
    }
    function renderBoard(){
      const container=document.getElementById('board');
      container.style.gridTemplateColumns=`repeat(${SIZE},1fr)`; container.innerHTML='';
      cells = Array.from({length:SIZE}, ()=> Array(SIZE).fill(null));
      for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++){
        const cell=document.createElement('div'); cell.className='cell'; cell.textContent=board[y][x];
        cell.dataset.x=x; cell.dataset.y=y;
        cell.addEventListener('click', ()=>chooseCell(x,y));
        cell.addEventListener('pointerdown', (e)=>onPointerDown(e,x,y));
        cell.addEventListener('pointerup', onPointerUp);
        cell.addEventListener('touchstart', (e)=>onPointerDown(e,x,y), {passive:true});
        cell.addEventListener('touchend', onPointerUp, {passive:true});
        cell.addEventListener('mousedown', (e)=>onPointerDown(e,x,y));
        cell.addEventListener('mouseup', onPointerUp);
        container.appendChild(cell); cells[y][x]=cell;
      }
    }
    function shuffleIfHasInitialMatches(maxTries=50){
      for (let i=0;i<maxTries;i++){
        if (findMatches().size===0) return;
        for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++){
          const rx=Math.floor(Math.random()*SIZE), ry=Math.floor(Math.random()*SIZE);
          const tmp=board[y][x]; board[y][x]=board[ry][rx]; board[ry][rx]=tmp;
        }
      }
    }

    // SW (escopo s√≥ desta pasta)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(()=>{});
    }

    // Init
    createBoard();
    shuffleIfHasInitialMatches();
    renderBoard();
  </script>
</body>
</html>
