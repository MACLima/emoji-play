<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emoji Crush</title>
  <meta name="theme-color" content="#0f172a" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --txt: #e5e7eb;
      --accent: #22d3ee;
      --accent-2: #a78bfa;
    }

    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans;
    }

    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    h1 { margin: 0 0 8px 0; font-size: clamp(1.2rem, 2.5vw, 1.8rem); }

    /* Navbar */
    .navbar { display: flex; border-bottom: 1px solid rgba(255,255,255,0.15); margin-bottom: 16px; }
    .nav-item {
      flex: 1; background: none; border: none; color: var(--txt);
      font-size: 14px; padding: 8px 0; cursor: pointer; text-align: center; transition: background .2s;
    }
    .nav-item:hover { background: rgba(255,255,255,0.05); }
    .nav-item.active { color: var(--accent); font-weight: 600; border-bottom: 2px solid var(--accent); }

    .board-wrap { display: flex; justify-content: center; }
    .board {
      display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px;
      background: var(--panel); padding: 4px; border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,.3); user-select: none; touch-action: none;
    }

    .cell {
      aspect-ratio: 1; font-size: 28px; display: flex; align-items: center; justify-content: center;
      background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer;
      transition: transform .1s, background .2s, box-shadow .2s, opacity .18s;
      will-change: transform, opacity;
    }
    .cell:hover { transform: scale(1.06); background: rgba(255,255,255,0.1); }
    .cell.selected {
      outline: 2px solid var(--accent); box-shadow: 0 0 0 2px var(--accent) inset; background: rgba(34,211,238,0.1);
    }
    .cell.flash { animation: flash .25s ease; }
    @keyframes flash { 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }

    .cell.match { background: rgba(255,255,255,0.18); }
    .cell.vanish { opacity: 0; transform: scale(0.85); }

    .hint { opacity: .75; font-size: 12px; text-align: center; margin-top: 10px; }

    /* Bloqueia cliques durante resolu√ß√£o */
    .busy .cell { pointer-events: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Emoji Crush</h1>

    <nav class="navbar">
      <button class="nav-item" onclick="location.href='index.html'">Leitor</button>
      <button class="nav-item active" onclick="location.href='emojicrush.html'">Jogo</button>
    </nav>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="Tabuleiro de emojis"></div>
    </div>

    <p class="hint">Troque dois vizinhos. A troca s√≥ vale se formar 3 ou mais. Cascatas acontecem automaticamente.</p>
  </div>

  <!-- √Åudios -->
  <audio id="swap-sound"  src="sounds/pop.mp3"   preload="auto"></audio>
  <audio id="match-sound" src="sounds/match.mp3" preload="auto"></audio>

  <script>
    // === Config ===
    const EMOJIS = ["üçé","üçå","üçá","üçì","üçç","üçä","üçí"];
    const SIZE = 8;

    // === Estado ===
    let board = [];          // board[y][x] => emoji | null
    let cells = [];          // cells[y][x] => elemento DOM
    let selected = null;     // {x,y, el}
    let dragStart = null;    // {x,y, clientX, clientY}
    let busy = false;        // bloqueia intera√ß√£o durante resolu√ß√£o

    // === Som: troca e match ===
    let swapSound, matchSound;

    function getSwapSound() {
      if (!swapSound) {
        swapSound = document.getElementById('swap-sound') || new Audio('sounds/pop.mp3');
        swapSound.volume = 0.6;
      }
      return swapSound;
    }
    function getMatchSound() {
      if (!matchSound) {
        matchSound = document.getElementById('match-sound') || new Audio('sounds/match.mp3');
        matchSound.volume = 0.7;
      }
      return matchSound;
    }
    // ‚ÄúPriming‚Äù para iOS (desbloqueia √°udio no primeiro gesto)
    function primeAudio() {
      const s1 = getSwapSound();
      const s2 = getMatchSound();
      try {
        s1.volume = 0; s1.play().then(() => { s1.pause(); s1.currentTime = 0; s1.volume = 0.6; }).catch(()=>{});
        s2.volume = 0; s2.play().then(() => { s2.pause(); s2.currentTime = 0; s2.volume = 0.7; }).catch(()=>{});
      } catch {}
      window.removeEventListener('pointerdown', primeAudio);
      window.removeEventListener('touchstart', primeAudio);
      window.removeEventListener('click', primeAudio);
    }
    window.addEventListener('pointerdown', primeAudio, { once: true });
    window.addEventListener('touchstart', primeAudio, { once: true });
    window.addEventListener('click', primeAudio, { once: true });

    function playSwapSound()  { const a = getSwapSound();  a.currentTime = 0; a.play().catch(()=>{}); }
    function playMatchSound() { const a = getMatchSound(); a.currentTime = 0; a.play().catch(()=>{}); }

    // === Util ===
    const inBounds = (x, y) => x >= 0 && x < SIZE && y >= 0 && y < SIZE;
    const randomEmoji = () => EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
    function isAdjacent(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1; }
    function setBusy(on) {
      busy = on;
      document.getElementById('board').classList.toggle('busy', on);
    }

    function swapModel(a, b) {
      const tmp = board[a.y][a.x];
      board[a.y][a.x] = board[b.y][b.x];
      board[b.y][b.x] = tmp;
    }

    function renderSwap(a, b) {
      const ea = cells[a.y][a.x], eb = cells[b.y][b.x];
      const tmpTxt = ea.textContent; ea.textContent = eb.textContent; eb.textContent = tmpTxt;
      ea.classList.add('flash'); eb.classList.add('flash'); playSwapSound();
      setTimeout(() => { ea.classList.remove('flash'); eb.classList.remove('flash'); }, 250);
    }

    function clearSelection() {
      if (selected?.el) selected.el.classList.remove('selected');
      selected = null;
    }

    // === MATCH LOGIC ===
    function findMatches() {
      // Retorna Set de chaves "x,y" a serem removidas
      const toClear = new Set();

      // Linhas
      for (let y = 0; y < SIZE; y++) {
        let runStart = 0;
        for (let x = 1; x <= SIZE; x++) {
          const cur = x < SIZE ? board[y][x] : null;
          const prev = board[y][x-1];
          if (cur !== prev || cur === null) {
            const runLen = x - runStart;
            if (prev !== null && runLen >= 3) {
              for (let k = runStart; k < x; k++) toClear.add(`${k},${y}`);
            }
            runStart = x;
          }
        }
      }

      // Colunas
      for (let x = 0; x < SIZE; x++) {
        let runStart = 0;
        for (let y = 1; y <= SIZE; y++) {
          const cur = y < SIZE ? board[y][x] : null;
          const prev = board[y-1][x];
          if (cur !== prev || cur === null) {
            const runLen = y - runStart;
            if (prev !== null && runLen >= 3) {
              for (let k = runStart; k < y; k++) toClear.add(`${x},${k}`);
            }
            runStart = y;
          }
        }
      }
      return toClear;
    }

    function markMatches(toClear) {
      toClear.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        cells[y][x].classList.add('match');
      });
    }

    function clearMatches(toClear) {
      playMatchSound(); // üîä som de match

      return new Promise(resolve => {
        // anima desaparecer
        toClear.forEach(key => {
          const [x, y] = key.split(',').map(Number);
          const cell = cells[y][x];
          cell.classList.add('vanish');
        });

        // depois de animar, zera no modelo e no DOM
        setTimeout(() => {
          toClear.forEach(key => {
            const [x, y] = key.split(',').map(Number);
            board[y][x] = null;
            const cell = cells[y][x];
            cell.textContent = '';
            cell.classList.remove('match', 'vanish');
          });
          resolve();
        }, 180);
      });
    }

    function applyGravity() {
      // Para cada coluna, compacta n√£o-nulos para baixo
      for (let x = 0; x < SIZE; x++) {
        let write = SIZE - 1;
        for (let y = SIZE - 1; y >= 0; y--) {
          if (board[y][x] !== null) {
            const val = board[y][x];
            if (y !== write) {
              board[write][x] = val;
              board[y][x] = null;
            }
            write--;
          }
        }
      }
      // Atualiza DOM
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          cells[y][x].textContent = board[y][x] || '';
        }
      }
    }

    function refill() {
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if (board[y][x] === null) {
            const e = randomEmoji();
            board[y][x] = e;
            cells[y][x].textContent = e;
          }
        }
      }
    }

    async function resolveBoardCascade() {
      while (true) {
        const matches = findMatches();
        if (matches.size === 0) break;
        markMatches(matches);
        await clearMatches(matches);
        applyGravity();
        refill();
        await new Promise(r => setTimeout(r, 60)); // respiro visual
      }
    }

    function swapAndResolve(a, b) {
      setBusy(true);
      // 1) swap
      swapModel(a, b);
      renderSwap(a, b);

      // 2) valida
      const hasMatch = findMatches().size > 0;
      if (!hasMatch) {
        // reverte
        setTimeout(() => {
          swapModel(a, b);
          renderSwap(a, b);
          setBusy(false);
        }, 140);
        return;
      }

      // 3) resolve cascata
      (async () => {
        await resolveBoardCascade();
        setBusy(false);
      })();
    }

    // === Intera√ß√£o ===
    function clearSelection() {
      if (selected?.el) selected.el.classList.remove('selected');
      selected = null;
    }

    function chooseCell(x, y) {
      if (busy) return;
      const el = cells[y][x];
      if (!selected) {
        selected = { x, y, el };
        el.classList.add('selected');
        return;
      }
      const other = { x, y, el };
      if (selected.x === x && selected.y === y) { clearSelection(); return; }
      if (!isAdjacent(selected, other)) {
        selected.el.classList.remove('selected');
        selected = other; selected.el.classList.add('selected'); return;
      }
      // adjacente -> tenta swap com valida√ß√£o
      selected.el.classList.remove('selected');
      const a = selected; const b = other; selected = null;
      swapAndResolve(a, b);
    }

    function onPointerDown(e, x, y) {
      if (busy) return;
      const touch = e.touches?.[0] || e;
      dragStart = { x, y, clientX: touch.clientX, clientY: touch.clientY };
      if (!selected) {
        selected = { x, y, el: cells[y][x] };
        selected.el.classList.add('selected');
      }
    }

    function onPointerUp(e) {
      if (busy) return;
      if (!dragStart) return;
      const touch = e.changedTouches?.[0] || e;
      const dx = touch.clientX - dragStart.clientX;
      const dy = touch.clientY - dragStart.clientY;

      const TH = 12; // px
      let nx = dragStart.x, ny = dragStart.y;

      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > TH) {
        nx = dragStart.x + (dx > 0 ? 1 : -1);
      } else if (Math.abs(dy) > TH) {
        ny = dragStart.y + (dy > 0 ? 1 : -1);
      } else {
        chooseCell(dragStart.x, dragStart.y);
        dragStart = null;
        return;
      }

      if (inBounds(nx, ny)) {
        const a = { x: dragStart.x, y: dragStart.y, el: cells[dragStart.y][dragStart.x] };
        const b = { x: nx, y: ny, el: cells[ny][nx] };
        if (selected?.el) selected.el.classList.remove('selected');
        selected = null;
        swapAndResolve(a, b);
      } else {
        clearSelection();
      }
      dragStart = null;
    }

    // === Board ===
    function createBoard() {
      board = Array.from({ length: SIZE }, () =>
        Array.from({ length: SIZE }, () => randomEmoji())
      );
    }

    function renderBoard() {
      const container = document.getElementById('board');
      container.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
      container.innerHTML = '';
      cells = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.textContent = board[y][x];
          cell.dataset.x = x; cell.dataset.y = y;

          cell.addEventListener('click', () => chooseCell(x, y));
          cell.addEventListener('pointerdown', (e) => onPointerDown(e, x, y));
          cell.addEventListener('pointerup', onPointerUp);
          cell.addEventListener('touchstart', (e) => onPointerDown(e, x, y), { passive: true });
          cell.addEventListener('touchend', onPointerUp, { passive: true });
          cell.addEventListener('mousedown', (e) => onPointerDown(e, x, y));
          cell.addEventListener('mouseup', onPointerUp);

          container.appendChild(cell);
          cells[y][x] = cell;
        }
      }
    }

    function shuffleIfHasInitialMatches(maxTries = 50) {
      for (let i = 0; i < maxTries; i++) {
        if (findMatches().size === 0) return;
        for (let y = 0; y < SIZE; y++) {
          for (let x = 0; x < SIZE; x++) {
            const rx = Math.floor(Math.random() * SIZE);
            const ry = Math.floor(Math.random() * SIZE);
            const tmp = board[y][x]; board[y][x] = board[ry][rx]; board[ry][rx] = tmp;
          }
        }
      }
    }

    // Init
    createBoard();
    shuffleIfHasInitialMatches();
    renderBoard();
  </script>
</body>
</html>
